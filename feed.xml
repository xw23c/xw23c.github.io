<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://xw23c.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://xw23c.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-08-21T09:13:02+00:00</updated><id>https://xw23c.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Functor</title><link href="https://xw23c.github.io/blog/2024/functor/" rel="alternate" type="text/html" title="Functor"/><published>2024-08-20T00:00:00+00:00</published><updated>2024-08-20T00:00:00+00:00</updated><id>https://xw23c.github.io/blog/2024/functor</id><content type="html" xml:base="https://xw23c.github.io/blog/2024/functor/"><![CDATA[<hr/> <p>layout: post title: STL Function Object date: 2024-08-20 16:55:00 description: intros to cpp stl functors tags: C++ STL functor categories: tech featured: true —</p> <h2 id="definition">Definition</h2> <p>Functor extends the concept of function by saying anything behave like a function is a function. A functor is a design pattern in programming that represents a function as an object. It is a way to package a function and its associated data into a single unit, allowing the function to be treated as an object. In essence, a functor is an object that: <strong>1</strong> <strong>Wraps a function</strong>: A functor contains a function as a member variable. <strong>2</strong> <strong>Provides a way to apply the function</strong>: A functor provides a way to apply the wrapped function to a set of inputs, often through an apply or call method. <strong>3</strong> <strong>Can be treated as an object</strong>: A functor can be passed around, stored, and manipulated like any other object.</p> <blockquote class="block-tip"> <h5 id="tip">TIP</h5> <p>Functor is a class or struct object that can be called like a function. It overloads the <strong>function-call operator</strong> () and allows us to use an object like a function.</p> </blockquote> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">X</span> <span class="p">{</span>

<span class="nl">public:</span>

    <span class="n">X</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{}</span>

    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">string</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Calling functor X with parameter "</span> <span class="o">&lt;&lt;</span> <span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">operator</span> <span class="n">string</span> <span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="s">"X"</span><span class="p">;}</span>  <span class="c1">// type conversion function</span>

<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>  <span class="n">X</span> <span class="nf">foo</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
  <span class="n">foo</span><span class="p">(</span><span class="s">"Hi!"</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="benefits-of-using-functor">Benefits of using functor</h2> <p>As object, functor can provide more things, often used in functional programming to:</p> <ul> <li><strong>Enable parameterized function</strong>: defining its own member data to remember states such that different function instance can be created</li> <li><strong>Abstract away low-level details</strong>: Functors can encapsulate complex logic and provide a simple interface to interact with it.</li> <li><strong>Enable function composition</strong>: Functors can be combined to create more complex functions.</li> <li><strong>Improve code reuse</strong>: Functors can be reused in different contexts.</li> </ul> <p>Due to those member data, you could have different instance of the same functor that behave different from each other. Regular functions are differentiated and identified by their function signatures. However, two functors can be of different types even if they have the same function signature.</p> <blockquote class="block-tip"> <h5 id="tip-1">TIP</h5> <p>Smart function: capabilities beyond operator() <br/>1. Define and record member states <br/>2. Possess its own type, enable instantiations</p> </blockquote> <h3 id="parameterized-function">Parameterized Function</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="rouge-code"><pre><span class="cm">/* Template way to parameterize the function
*  downside: temporary variable val has to be resolved at compile
*  time, i.e being a conpile time constant
*/</span>


<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">val</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">addVal</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">+</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Use Functor */</span>

<span class="k">class</span> <span class="nc">AddVal</span> <span class="p">{</span>

<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>

<span class="nl">public:</span>
    <span class="n">AddVal</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">+</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">};</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>

    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="c1">// for_each(vec.begin(), vec.end(), addVal&lt;x&gt;); // compile error : x has to be compile time constant</span>

    <span class="n">for_each</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">AddVal</span><span class="p">(</span><span class="n">x</span><span class="p">));</span> <span class="c1">// ok!</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="built-in-functors-">Built-in functors <sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">1</a></sup></h2> <p>To use the predefined functors provided by the standard library by including the functional header file <code class="language-plaintext highlighter-rouge">#include &lt;functional&gt;</code></p> <p>C++ provides the following library functors for arithmetic, relational, and logical operations:</p> <ul> <li>Relational Functors: <code class="language-plaintext highlighter-rouge">less, greater, greater_equal, less_equal, not_equal_to</code></li> <li>Logical Functors: <code class="language-plaintext highlighter-rouge">logical_and, logical_not, logical_or</code></li> <li>Arithmetic Functors: <code class="language-plaintext highlighter-rouge">multiplies, minus, plus, divide, modulus, negate</code></li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">multiplies</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// x = 3 * 4</span>

<span class="k">if</span> <span class="p">(</span><span class="n">not_equal_to</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">x</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span> <span class="c1">// if (x != 10)</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>(Details ref : <sup id="fnref:2:1" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">1</a></sup>)</p> <h2 id="parameter-binding">Parameter Binding</h2> <p>Combine functor with <em>bind</em> function :</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="n">bind</span><span class="p">()</span> <span class="c1">// available c++11</span>
<span class="n">bind1st</span><span class="p">()</span> <span class="c1">// c++03</span>
<span class="n">bind2nd</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></pre></div></div> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">myset</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>

<span class="n">transform</span><span class="p">(</span><span class="n">myset</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">myset</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>        <span class="c1">// source</span>
    			<span class="n">back_inserter</span><span class="p">(</span><span class="n">res</span><span class="p">),</span>              <span class="c1">// destination</span>
    			<span class="c1">//bind2nd(multiplies&lt;int&gt;(),10));       // functor</span>
    			<span class="n">bind</span><span class="p">(</span><span class="n">multiplies</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">,</span> <span class="mi">10</span><span class="p">));</span>
			<span class="c1">// bind() - c++11</span>

<span class="c1">// First element of multiplies is substituted by with myset`s element and second by 10</span>
<span class="c1">// res: {20,30,40,50}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="functor-composing">Functor composing</h2> <p>Construct composite functors using bind function :</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre>
<span class="cm">/*
*	 when (x &gt; 2) &amp;&amp; (x &lt; 5) , copy from myset to res2_dq
*/</span>

<span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res2_dq</span><span class="p">;</span>

<span class="n">transform</span><span class="p">(</span><span class="n">myset</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">myset</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">back_inserter</span><span class="p">(</span><span class="n">res2_dq</span><span class="p">),</span>
            <span class="n">bind</span><span class="p">(</span><span class="n">logical_and</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(),</span>
            <span class="n">bind</span><span class="p">(</span><span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
            <span class="n">bind</span><span class="p">(</span><span class="n">less</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
        <span class="p">);</span>

<span class="c1">// c++11 Lambda function</span>
<span class="n">transform</span><span class="p">(</span><span class="n">myset</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">myset</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">back_inserter</span><span class="p">(</span><span class="n">res2_dq</span><span class="p">),</span>
            <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span><span class="k">return</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;}</span>
        <span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="function-wrapper-object-">Function wrapper object <sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">2</a></sup></h2> <p>Convert regular function to functor. Use function class template to do so :</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">function</span>	<span class="c1">// c++11</span>
<span class="n">std</span><span class="o">::</span><span class="n">ptr_fun</span>		<span class="c1">// c++03</span>
</pre></td></tr></tbody></table></code></pre></div></div> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res_dq</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">function</span><span class="o">&lt;</span><span class="kt">double</span> <span class="p">(</span><span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Pow</span><span class="p">);</span>

<span class="n">transform</span><span class="p">(</span><span class="n">myset</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">myset</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">back_inserter</span><span class="p">(</span><span class="n">res_dq</span><span class="p">),</span>
    <span class="n">bind</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">));</span>

</pre></td></tr></tbody></table></code></pre></div></div> <p>(Details ref: <sup id="fnref:3:1" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">2</a></sup>)</p> <h2 id="relational-functor-in-stl">Relational functor in STL</h2> <p>Ordered containers in STL are templates classes that initialized with relational functors, which are used for elements ordering. Default relational functor were usually set as <code class="language-plaintext highlighter-rouge">less</code>. On purpose of use case, we can customize this relational functor.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Lsb_less</span> <span class="p">{</span>
    <span class="nl">public:</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="o">%</span><span class="mi">10</span><span class="p">)</span><span class="o">&lt;</span><span class="p">(</span><span class="n">b</span><span class="o">%</span><span class="mi">10</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

 <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Lsb_less</span><span class="o">&gt;</span> <span class="n">myset2</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">12</span><span class="p">};</span> <span class="c1">// myset2 : {1,12,3,25,7}</span>

</pre></td></tr></tbody></table></code></pre></div></div> <blockquote class="block-tip"> <p>#####Concept - Predicate A function or functor such that : <br/>1. Returns a boolean <br/>2. Does not modify date <br/> Commonly used for comparison or condition check</p> </blockquote> <h2 id="reference">Reference</h2> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:2" role="doc-endnote"> <p>[[[C++ Functors](https:\/\/www.programiz.com\/cpp-programming\/functors)]] <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:2:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p> </li> <li id="fn:3" role="doc-endnote"> <p>[[ [std::function](https:\/\/en.cppreference.com\/w\/cpp\/utility\/functional\/function)]] <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:3:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p> </li> </ol> </div>]]></content><author><name></name></author><summary type="html"><![CDATA[layout: post title: STL Function Object date: 2024-08-20 16:55:00 description: intros to cpp stl functors tags: C++ STL functor categories: tech featured: true —]]></summary></entry><entry><title type="html">Threading Data Race</title><link href="https://xw23c.github.io/blog/2024/data-race/" rel="alternate" type="text/html" title="Threading Data Race"/><published>2024-08-08T16:34:00+00:00</published><updated>2024-08-08T16:34:00+00:00</updated><id>https://xw23c.github.io/blog/2024/data-race</id><content type="html" xml:base="https://xw23c.github.io/blog/2024/data-race/"><![CDATA[<h2 id="what-is-data-race">What is data race</h2> <p>In C++, data race is a commonly occurring problem in concurrent programming. It occurs when two or more threads concurrently access the same memory location, and at least one of the accesses is a write. Data races lead to undefined behavior, which means the program can exhibit unpredictable behavior, crash, or produce incorrect results.</p> <h2 id="mutual-exclusion-with-raii">Mutual exclusion with RAII</h2> <p>Use <code class="language-plaintext highlighter-rouge">mutex()</code> to synchronize the access to common resource. The name <em>mutex</em> comes from mutual exclusion. However, we should avoid to use the mutex directly since it is not <em>exception-safe</em>. Instead, the RALL(Resource Acquisition is Initialization) approach is recommended, which will wrap the mutex and it will aways get guaranteed to be unlocked after the wrapper guard gets out of scope.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mu</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">shared_print</span><span class="p">(</span><span class="n">string</span> <span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>

    <span class="cm">/* As follows avoiding use std::mutex directly which is not exception safe.
    Instead, use std::lock_guard according to RAII.
    */</span>


    <span class="c1">//RAII, when guard goes out of scope, the mutex always gets unlocked automatically</span>
    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">guard</span><span class="p">(</span><span class="n">mu</span><span class="p">);</span>


    <span class="c1">// mu.lock();</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[ID-"</span> <span class="o">&lt;&lt;</span> <span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="s">"]"</span> <span class="o">&lt;&lt;</span> <span class="n">msg</span> <span class="o">&lt;&lt;</span> <span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="c1">// mu.unlock();</span>
<span class="p">}</span>



<span class="kt">void</span> <span class="nf">func_1</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&gt;-</span><span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">shared_print</span><span class="p">(</span><span class="n">string</span><span class="p">(</span><span class="s">"From child_t: "</span><span class="p">),</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">child_t</span><span class="p">(</span><span class="n">func_1</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">shared_print</span><span class="p">(</span><span class="n">string</span><span class="p">(</span><span class="s">"From main: "</span><span class="p">),</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">child_t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


</pre></td></tr></tbody></table></code></pre></div></div> <p>Even though we adopt RAII above, there still be one pitfall. That is the <em>cout</em>, which is not completely under the protection of mutex <em>mu</em> since it is a global variable and other thread still can use it directly without going through the mutex lock.</p> <h2 id="resource-bundled-mutual-exclusion-rbmutex-">Resource bundled mutual exclusion (RBMutex) <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></h2> <p>To make the resource fully protected, we exploit resource instantiation and bundle it together with the mutex lock.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
</pre></td><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">class</span> <span class="nc">LogFile</span> <span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m_mutex</span><span class="p">;</span>
	<span class="n">ofstream</span> <span class="n">f</span><span class="p">;</span>

<span class="nl">public:</span>
	<span class="n">LogFile</span><span class="p">()</span> <span class="p">{</span><span class="n">f</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">"log.txt"</span><span class="p">);}</span>
	<span class="kt">void</span> <span class="nf">shared_print</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">;</span>
	<span class="o">~</span><span class="n">LogFile</span><span class="p">()</span> <span class="p">{</span><span class="n">f</span><span class="p">.</span><span class="n">close</span><span class="p">();}</span>

<span class="p">};</span>


<span class="kt">void</span> <span class="n">LogFile</span><span class="o">::</span><span class="n">shared_print</span><span class="p">(</span><span class="n">string</span> <span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>

	<span class="cm">/* As follows avoiding use std::mutex directly which is not exception safe.
	Instead, use std::lock_guard according to RAII.
	*/</span>


	<span class="c1">//RAII, when guard goes out of scope, the mutex always gets unlocked automatically</span>
	<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">guard</span><span class="p">(</span><span class="n">m_mutex</span><span class="p">);</span>


	<span class="c1">// mu.lock();</span>
	<span class="k">this</span><span class="o">-&gt;</span><span class="n">f</span> <span class="o">&lt;&lt;</span> <span class="s">"[ID("</span> <span class="o">&lt;&lt;</span> <span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="s">")]"</span> <span class="o">&lt;&lt;</span> <span class="n">msg</span> <span class="o">&lt;&lt;</span> <span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="c1">// mu.unlock();</span>
<span class="p">}</span>



<span class="kt">void</span> <span class="nf">func_1</span><span class="p">(</span><span class="n">LogFile</span><span class="o">&amp;</span> <span class="n">log</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&gt;-</span><span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">log</span><span class="p">.</span><span class="n">shared_print</span><span class="p">(</span><span class="n">string</span><span class="p">(</span><span class="s">"From child_t: "</span><span class="p">),</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

	<span class="n">LogFile</span> <span class="n">log</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">child_t</span><span class="p">(</span><span class="n">func_1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">log</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">log</span><span class="p">.</span><span class="n">shared_print</span><span class="p">(</span><span class="n">string</span><span class="p">(</span><span class="s">"From main: "</span><span class="p">),</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">child_t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></td></tr></tbody></table></code></pre></div></div> <p>Keep in mind that never to leak the resource to the outside world. Following are examples considered as bad implementation:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">LogFile</span><span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mu</span><span class="p">;</span>
	<span class="n">ofstream</span> <span class="n">f</span><span class="p">;</span>

<span class="nl">public:</span>
	<span class="p">...</span>

	<span class="c1">// Bad idea to return f to outside world</span>
	<span class="n">ofstream</span><span class="o">&amp;</span> <span class="n">getStream</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="n">f</span><span class="p">;}</span>
	<span class="c1">// Bad idea to pass f as argument to user-provided function</span>
	<span class="kt">void</span> <span class="nf">processf</span><span class="p">(</span><span class="kt">void</span> <span class="n">func_user</span><span class="p">(</span><span class="n">ofstream</span><span class="o">&amp;</span><span class="p">)){</span>
		<span class="n">func_user</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="reference">Reference</h2> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1" role="doc-endnote"> <p><a href="https://www.youtube.com/watch?v=3ZxZPeXPaM4&amp;list=PL5jc9xFGsL8E12so1wlMS0r0hTQoJL74M&amp;index=3&amp;t=355s">C++ Threading #3: Data Race and Mutex</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name></name></author><category term="tech"/><category term="C++"/><category term="Concurrency"/><summary type="html"><![CDATA[intros to cpp mutex]]></summary></entry><entry><title type="html">Threading first lesson</title><link href="https://xw23c.github.io/blog/2024/thread/" rel="alternate" type="text/html" title="Threading first lesson"/><published>2024-08-06T16:24:00+00:00</published><updated>2024-08-06T16:24:00+00:00</updated><id>https://xw23c.github.io/blog/2024/thread</id><content type="html" xml:base="https://xw23c.github.io/blog/2024/thread/"><![CDATA[<h2 id="overview-">Overview <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></h2> <p>There are two types of concurrent programming model: multi-processing and multi-threading. Comparing to multi-processing, the multi-threading characterize:</p> <ul> <li>Pros <ul> <li>fast to start</li> <li>low overhead</li> </ul> </li> <li>Cons <ul> <li>difficult to implement</li> <li>cannot run on distributed system</li> </ul> </li> </ul> <p>Example code of threading:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;thread&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">function_1</span><span class="p">(){</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"Reality is merely an illusion, albeit a very persistent one."</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">function_1</span><span class="p">);</span> <span class="c1">// t starts running</span>
	<span class="c1">// t.join(); // main thread waits for thread t to finish</span>
	<span class="n">t</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span>	<span class="c1">// t goes freely on its own -- daemon process</span>

	<span class="cm">/* join or detach can only operated once
	 cannot join anymore once get detach */</span>

	<span class="c1">// check if joinable</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span> <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="thread-management-">Thread management <sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></h2> <h3 id="try-catch-block">Try-Catch block</h3> <p>Child thread destroyed (eg. thread goes out of scope) before <code class="language-plaintext highlighter-rouge">.join/.detach</code> , the program then terminates. This can be caused by exceptions from the parent thread. To avoid this problem, one solution is to use try-catch block.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">function_1</span><span class="p">(){</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"Reality is merely an illusion, albeit a very persistent one."</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;};</span>

<span class="kt">void</span> <span class="nf">parent_thread_works</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"from main: "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">function_1</span><span class="p">);</span> <span class="c1">// t starts running</span>

	<span class="cm">/* Use try-catch to wrap up the parent thread`s work.
	This will ensure the child thread to be joined w/wo
	exceptions */</span>
	<span class="k">try</span> <span class="p">{</span>
		<span class="n">parent_thread_works</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>  <span class="c1">// catch any exceptions</span>
		<span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
		<span class="k">throw</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Another way is to use RAII, create wrapper class w(t)
	whoes destructor will join t automatically*/</span>

	<span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h3 id="pass-by-reference">Pass by reference</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Fctor</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"t says: "</span> <span class="o">&lt;&lt;</span> <span class="n">msg</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"Reality is merely an illusion, albeit a very persistent one."</span><span class="p">;</span>

	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ID of main thread"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

	<span class="c1">// another pair of parathesis added to explicily declare Fctor()</span>
	<span class="c1">// constructed as a functor</span>
	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">((</span><span class="n">Fctor</span><span class="p">()),</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>

	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ID of child thread: "</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">.</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

	<span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

	<span class="c1">// child and parent thread sharing the same memory, ie. the string s</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"from main: "</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>As in above example, though we have <code class="language-plaintext highlighter-rouge">string&amp; msg</code> in declaration, the <code class="language-plaintext highlighter-rouge">thread()</code> constructor will still take in value. So it still keeps as passing by value. To force using pass by reference, we use</p> <blockquote> <p><code class="language-plaintext highlighter-rouge">std::ref(s) // Create a reference wrapper</code></p> </blockquote> <h3 id="pass-by-pointer">Pass by pointer</h3> <p>Note in the example, parent and child share the same memory, the string <em>s</em>. Suppose we don’t prefer this way, since memory sharing causes data racing problem. And we don’t prefer to pass data by value. In such case we can pass parameter use the <code class="language-plaintext highlighter-rouge">move()</code> function</p> <blockquote> <p><code class="language-plaintext highlighter-rouge">std::move(s) // move the string s from the main thread to the child thread</code> In Cpp there many things can only be moved and cannot be copied, such as the thread object ```cpp int main() { string s = “Reality is merely an illusion, albeit a very persistent one.”;</p> </blockquote> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>std::thread t((Fctor()), std::move(s));

//std::thread t2 = t; // cannot compile
std::thread t2 = std::move(t);

t2.join();

return 0; } ```
</pre></td></tr></tbody></table></code></pre></div></div> <h3 id="identification">Identification</h3> <p>Following functions can be used to display the thread id</p> <blockquote> <p><code class="language-plaintext highlighter-rouge">std::this_thread::get_id() // id of current thread</code> <code class="language-plaintext highlighter-rouge">thread_t.get_id() // id of thread t</code></p> </blockquote> <h3 id="oversubscription">Oversubscription</h3> <p>Ideally we create number of threads as many as the number of cores we have. To run more threads than hardware support is called <em>oversubscription</em>, which will create lots of contact switching and decrease the performance. The library provides function that give indication how many threads should be truly used for concurrency:</p> <blockquote> <p><code class="language-plaintext highlighter-rouge">std::thread::hardware_concurrency()</code></p> </blockquote> <h2 id="reference">Reference</h2> <hr/> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1" role="doc-endnote"> <p><a href="https://www.youtube.com/watch?v=LL8wkskDlbs&amp;list=PL5jc9xFGsL8E12so1wlMS0r0hTQoJL74M">C++ Threading #1: Introduction</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:2" role="doc-endnote"> <p><a href="https://www.youtube.com/watch?v=f2nMqNj7vxE&amp;list=PL5jc9xFGsL8E12so1wlMS0r0hTQoJL74M&amp;index=3">C++ Threading #2: Thread Management</a> <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name></name></author><category term="tech"/><category term="C++"/><category term="Concurrency"/><summary type="html"><![CDATA[intros to cpp multi-threading]]></summary></entry><entry><title type="html">Unordered Associative Container</title><link href="https://xw23c.github.io/blog/2024/unordered-container/" rel="alternate" type="text/html" title="Unordered Associative Container"/><published>2024-08-04T16:38:00+00:00</published><updated>2024-08-04T16:38:00+00:00</updated><id>https://xw23c.github.io/blog/2024/unordered-container</id><content type="html" xml:base="https://xw23c.github.io/blog/2024/unordered-container/"><![CDATA[<h2 id="the-containers">The containers</h2> <p>The order of elements is not defined and it changes over the time. Internally they are implemented by hash table (an array of linked list, a.k.a array of buckets, the grey boxes in bellow graph, and the slots on the linked list also called entries).</p> <blockquote class="block-tip"> <h5 id="tip">TIP</h5> <p>Fast and effective hash function can guarantee fast search time (constant)</p> </blockquote> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/unorderedset-480.webp 480w,/assets/img/unorderedset-800.webp 800w,/assets/img/unorderedset-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/unorderedset.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/unorderedmap-480.webp 480w,/assets/img/unorderedmap-800.webp 800w,/assets/img/unorderedmap-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/unorderedmap.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p><em>Figure 1. Internal structure of unordered sets/multisets(left) and map/multimaps(right)</em> <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p> <table> <thead> <tr> <th style="text-align: left">unordered accos. containers</th> <th style="text-align: center">header</th> <th style="text-align: center">RA</th> <th style="text-align: center">dup.</th> <th style="text-align: center">feature</th> <th style="text-align: center">Impl.</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">unordered_set&lt;T&gt;</td> <td style="text-align: center">&lt;unordered_set&gt;</td> <td style="text-align: center">false</td> <td style="text-align: center">forbid</td> <td style="text-align: center">value cant be changed</td> <td style="text-align: center">hash table</td> </tr> <tr> <td style="text-align: left">unordered_multiset&lt;T&gt;</td> <td style="text-align: center">&lt;unordered_set&gt;</td> <td style="text-align: center">false</td> <td style="text-align: center">allow</td> <td style="text-align: center">value cant be changed</td> <td style="text-align: center">hash table</td> </tr> <tr> <td style="text-align: left">unordered_map&lt;T, T&gt;</td> <td style="text-align: center">&lt;unordered_map&gt;￼</td> <td style="text-align: center">false</td> <td style="text-align: center">forbid</td> <td style="text-align: center">key cant be changed</td> <td style="text-align: center">hash table</td> </tr> <tr> <td style="text-align: left">unordered_multimap&lt;T, T&gt;</td> <td style="text-align: center">&lt;unordered_map&gt;￼</td> <td style="text-align: center">false</td> <td style="text-align: center">allow</td> <td style="text-align: center">key cant be changed</td> <td style="text-align: center">hash table</td> </tr> </tbody> </table> <p>Note the change of value (value for sets, key for maps) will corrupt the data structure of hash table, thus it is forbidden by definition in nature.</p> <blockquote class="block-warning"> <h5 id="warning">WARNING</h5> <p>Read-only properties: <br/>Unordered set/multiset: element value cannot be changed <br/>Unordered map/multimap: element key cannot be changed</p> </blockquote> <blockquote class="block-warning"> <h5 id="warning-1">WARNING</h5> <p>Multimaps do not promise unique keys, therefore they don’t support subscript operator [-].</p> </blockquote> <p>Example code (unorder_set):</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unordered_set&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>



<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="cm">/*  unordered map
    */</span>
    <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">myset</span><span class="p">{</span><span class="s">"red"</span><span class="p">,</span> <span class="s">"green"</span><span class="p">,</span> <span class="s">"blue"</span><span class="p">};</span>
    <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">myset</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">"red"</span><span class="p">);</span> <span class="c1">// O(1)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="o">!=</span><span class="n">myset</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>     <span class="c1">// check if element found</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="n">myset</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">"yellow"</span><span class="p">);</span> <span class="c1">// O(1)</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">{</span><span class="s">"purple"</span><span class="p">,</span> <span class="s">"pink"</span><span class="p">};</span>
    <span class="n">myset</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>


    <span class="cm">/*  hash table APIs
    */</span>


    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"load_factor(total num of elements / total num of buckets)"</span>
        <span class="o">&lt;&lt;</span> <span class="n">myset</span><span class="p">.</span><span class="n">load_factor</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="c1">// string x{"red"};</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">string</span> <span class="n">x</span><span class="o">:</span> <span class="n">myset</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">" is in bucket : "</span> <span class="o">&lt;&lt;</span> <span class="n">myset</span><span class="p">.</span><span class="n">bucket</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Total bucket count: "</span> <span class="o">&lt;&lt;</span> <span class="n">myset</span><span class="p">.</span><span class="n">bucket_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>

</pre></td></tr></tbody></table></code></pre></div></div> <p>Example code (unordered_map):</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span>  <span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">m</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">dayS</span><span class="p">;</span>   <span class="c1">//, {'M', "Monday"}};</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">day</span><span class="p">[</span><span class="sc">'S'</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// No range check</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">day</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="sc">'S'</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// Has range check</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
    <span class="n">vec</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span> <span class="p">;</span> <span class="c1">// Compile Error, vec[5] not created yet</span>

    <span class="n">day</span><span class="p">[</span><span class="sc">'W'</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Wednesday"</span><span class="p">;</span>  <span class="c1">// Inserting {'W', "wednesday"}</span>
    <span class="n">day</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="sc">'F'</span><span class="p">,</span> <span class="s">"Friday"</span><span class="p">));</span>

    <span class="n">day</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="sc">'M'</span><span class="p">,</span> <span class="s">"Monday"</span><span class="p">));</span>
    <span class="n">day</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="sc">'M'</span><span class="p">,</span> <span class="s">"MONDAY"</span><span class="p">));</span> <span class="c1">// fail to modify. For unordered_map, cannot use insert() to modify elements</span>
    <span class="n">day</span><span class="p">[</span><span class="sc">'M'</span><span class="p">]</span> <span class="o">=</span> <span class="s">"MONDAY"</span><span class="p">;</span>                  <span class="c1">// succeed to modify. Subscript operator provide write access to the container</span>


    <span class="n">foo</span><span class="p">(</span><span class="n">day</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span>  <span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>

    <span class="cm">/* line bellow fails to compile.
    Compiler sees the subscript operrator [-], which provide write access,
    and this vialate the const keyword protect
    */</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">m</span><span class="p">[</span><span class="sc">'S'</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="c1">// to print element of S</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">'S'</span><span class="p">);</span> <span class="n">it</span><span class="o">!=</span><span class="n">m</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"key: "</span> <span class="o">&lt;&lt;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">", value: "</span> <span class="o">&lt;&lt;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"not found!"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

<span class="p">}</span>

</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="performance-">Performance <sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></h2> <table> <thead> <tr> <th style="text-align: left"><em>action</em></th> <th style="text-align: left"><em>unordered associative containers</em></th> </tr> </thead> <tbody> <tr> <td style="text-align: left"> </td> <td style="text-align: left">unordered set/multiset/map/multimap</td> </tr> <tr> <td style="text-align: left">insert/remove (.insert/.erase)</td> <td style="text-align: left">\(O(1)\) - amortized constant</td> </tr> <tr> <td style="text-align: left">search (.find)</td> <td style="text-align: left">\(O(1)\) - amortized</td> </tr> <tr> <td style="text-align: left">traverse</td> <td style="text-align: left">n/a</td> </tr> </tbody> </table> <p>They possess the <strong>fastest</strong> insert and search time at any place - \(O(1)\). However, this is <strong>amortized</strong> constant time due to potential rare case of hash collisions. (<em>Amortized time</em> here indicates “average time taken per operation given that the same operation repeats many times”<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>)</p> <h3 id="hash-collision">Hash collision</h3> <p>This indicate many items are inserted at the same buckets, and majority of them then are only inserted into a few buckets. The performance of searching will degrade from constant time \(O(1)\) to linear time \(O(n)\)</p> <blockquote class="block-tip"> <h5 id="tip-1">TIP</h5> <p>Unordered map provides amortized constant time, but it may degrade to linear time, while ordered map can guarantee \(O(log(n))\) time. This is important for real time system.</p> </blockquote> <h3 id="reference">Reference</h3> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1" role="doc-endnote"> <p>Nicolai M. Josuttis, <em>The C++ Standard Library 2nd Edition</em> : p. 358 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:2" role="doc-endnote"> <p>Bo Qian, <em><a href="https://www.youtube.com/watch?v=NNLvY9O7ufU&amp;list=PL5jc9xFGsL8G3y3ywuFSvOuNm3GjBwdkb&amp;index=5">Introduction of STL #4: Unordered Containers</a></em> <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:3" role="doc-endnote"> <p><a href="https://stackoverflow.com/questions/200384/what-is-constant-amortized-time">what-is-constant-amortized-time</a> <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name></name></author><category term="tech"/><category term="C++"/><category term="STL"/><category term="container"/><summary type="html"><![CDATA[STL unordered containers]]></summary></entry><entry><title type="html">C++ Templates</title><link href="https://xw23c.github.io/blog/2024/cpp-templates/" rel="alternate" type="text/html" title="C++ Templates"/><published>2024-08-03T22:09:00+00:00</published><updated>2024-08-03T22:09:00+00:00</updated><id>https://xw23c.github.io/blog/2024/cpp-templates</id><content type="html" xml:base="https://xw23c.github.io/blog/2024/cpp-templates/"><![CDATA[<h2 id="brief-intro-to-templates-">Brief intro to templates <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></h2> <p>Template methodology suits for generic designing</p> <ol> <li>function template</li> <li>class template</li> </ol> <p>The differences between these two types:</p> <ul> <li>function template can infer the data type from its parameter, so it need not explicit declaration of data type that passed in, but for class templates this need to be done explicitly</li> </ul> <p>Example of templates:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre></td><td class="rouge-code"><pre><span class="c1">// with standard C++ 11 and above</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="c1"> // std::cout</span><span class="cp">
#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="c1"> // std::ostream_iterator</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="c1"> // std::copy</span><span class="cp">
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span> <span class="nf">square</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">MyVector</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">arr</span><span class="p">[</span><span class="mi">1000</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

<span class="nl">public:</span>
    <span class="n">MyVector</span><span class="p">()</span> <span class="o">:</span> <span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>

<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span><span class="n">arr</span><span class="p">[</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="n">size</span><span class="o">++</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[]</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">;</span>
    <span class="n">MyVector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span> <span class="p">(</span><span class="n">MyVector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">MyVector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">print</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Vector Size : "</span> <span class="o">&lt;&lt;</span> <span class="n">size</span> <span class="o">&lt;&lt;</span> <span class="s">", Elements: "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span>
        <span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">+</span><span class="n">size</span><span class="p">,</span>
        <span class="n">std</span><span class="o">::</span><span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">,</span> <span class="s">","</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span><span class="o">&amp;</span> <span class="n">MyVector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="k">operator</span><span class="p">[]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>  <span class="p">{</span>
    <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">MyVector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">MyVector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="k">operator</span><span class="o">*</span>  <span class="p">(</span><span class="n">MyVector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">v_other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">MyVector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">v_res</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">v_res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">v_other</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">v_res</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">MyVector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
    <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"Print MyVector: </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">vec</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"</span><span class="se">\n</span><span class="s">Print square of MyVector: </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">square</span><span class="p">(</span><span class="n">vec</span><span class="p">).</span><span class="n">print</span><span class="p">();</span>

<span class="p">}</span>

</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="code-bloat-">Code bloat <sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></h2> <p>Def: code bloat refer to the production of code is unnecessarily long, and hence results in software Inefficiency, slow in execution and compiling.</p> <p>Reasons behind include</p> <ol> <li>Definition in header file would compile every time when it is used in any source code file separately. Even though any functionality feature (i.e function etc) from that header is never used, it will still be compiled. This slows the built time.</li> <li>As downside from template usage, every instance of a template is a completely separate piece of code generate by compiler. Templates were compiled as many times as they were called for each instantiation as per specific used parameters.</li> </ol> <p>Ways to overcome this issue</p> <ol> <li>Define template functions in source file and explicitly instantiate them.</li> <li>Use extern template declarations in header, combined with explicit template instantiations in source files itself.</li> </ol> <h2 id="reference">Reference</h2> <hr/> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1" role="doc-endnote"> <p>[[[Learn STL: Introduction of Templates](https:\/\/www.youtube.com\/watch?v=Vc1RyqWFbiA\&amp;list=PL5jc9xFGsL8G3y3ywuFSvOuNm3GjBwdkb\&amp;index=2)]] <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:2" role="doc-endnote"> <p>[[[Code Bloating in C++ with Examples](https:\/\/www.geeksforgeeks.org\/code-bloating-in-c-with-examples\/)]] <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name></name></author><category term="tech"/><category term="C++"/><category term="STL"/><summary type="html"><![CDATA[essentials of C++ templates]]></summary></entry><entry><title type="html">Google Gemini updates: Flash 1.5, Gemma 2 and Project Astra</title><link href="https://xw23c.github.io/blog/2024/google-gemini-updates-flash-15-gemma-2-and-project-astra/" rel="alternate" type="text/html" title="Google Gemini updates: Flash 1.5, Gemma 2 and Project Astra"/><published>2024-05-14T00:00:00+00:00</published><updated>2024-05-14T00:00:00+00:00</updated><id>https://xw23c.github.io/blog/2024/google-gemini-updates-flash-15-gemma-2-and-project-astra</id><content type="html" xml:base="https://xw23c.github.io/blog/2024/google-gemini-updates-flash-15-gemma-2-and-project-astra/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[We’re sharing updates across our Gemini family of models and a glimpse of Project Astra, our vision for the future of AI assistants.]]></summary></entry><entry><title type="html">a post with tabs</title><link href="https://xw23c.github.io/blog/2024/tabs/" rel="alternate" type="text/html" title="a post with tabs"/><published>2024-05-01T00:32:13+00:00</published><updated>2024-05-01T00:32:13+00:00</updated><id>https://xw23c.github.io/blog/2024/tabs</id><content type="html" xml:base="https://xw23c.github.io/blog/2024/tabs/"><![CDATA[<p>This is how a post with <a href="https://github.com/Ovski4/jekyll-tabs">tabs</a> looks like. Note that the tabs could be used for different purposes, not only for code.</p> <h2 id="first-tabs">First tabs</h2> <p>To add tabs, use the following syntax:</p> <div class="language-liquid highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="cp">{%</span><span class="w"> </span><span class="nt">tabs</span><span class="w"> </span><span class="nv">group-name</span><span class="w"> </span><span class="cp">%}</span>

<span class="cp">{%</span><span class="w"> </span><span class="nt">tab</span><span class="w"> </span><span class="nv">group-name</span><span class="w"> </span><span class="nv">tab-name-1</span><span class="w"> </span><span class="cp">%}</span>

Content 1

<span class="cp">{%</span><span class="w"> </span><span class="nt">endtab</span><span class="w"> </span><span class="cp">%}</span>

<span class="cp">{%</span><span class="w"> </span><span class="nt">tab</span><span class="w"> </span><span class="nv">group-name</span><span class="w"> </span><span class="nv">tab-name-2</span><span class="w"> </span><span class="cp">%}</span>

Content 2

<span class="cp">{%</span><span class="w"> </span><span class="nt">endtab</span><span class="w"> </span><span class="cp">%}</span>

<span class="cp">{%</span><span class="w"> </span><span class="nt">endtabs</span><span class="w"> </span><span class="cp">%}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>With this you can generate visualizations like:</p> <ul id="log" class="tab" data-tab="b80acbd8-d101-49b0-990c-92021df5a715" data-name="log"> <li class="active" id="log-php"> <a href="#">php </a> </li> <li id="log-js"> <a href="#">js </a> </li> <li id="log-ruby"> <a href="#">ruby </a> </li> </ul> <ul class="tab-content" id="b80acbd8-d101-49b0-990c-92021df5a715" data-name="log"> <li class="active"> <div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nb">var_dump</span><span class="p">(</span><span class="s1">'hello'</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div> </li> <li> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">hello</span><span class="dl">"</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div> </li> <li> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nx">pputs</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span>
</pre></td></tr></tbody></table></code></pre></div></div> </li> </ul> <h2 id="another-example">Another example</h2> <ul id="data-struct" class="tab" data-tab="aaba0e39-5b21-4298-8dc3-246e2006112f" data-name="data-struct"> <li class="active" id="data-struct-yaml"> <a href="#">yaml </a> </li> <li id="data-struct-json"> <a href="#">json </a> </li> </ul> <ul class="tab-content" id="aaba0e39-5b21-4298-8dc3-246e2006112f" data-name="data-struct"> <li class="active"> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="na">hello</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s2">"</span><span class="s">whatsup"</span>
  <span class="pi">-</span> <span class="s2">"</span><span class="s">hi"</span>
</pre></td></tr></tbody></table></code></pre></div></div> </li> <li> <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="p">{</span><span class="w">
  </span><span class="nl">"hello"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"whatsup"</span><span class="p">,</span><span class="w"> </span><span class="s2">"hi"</span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div> </li> </ul> <h2 id="tabs-for-something-else">Tabs for something else</h2> <ul id="something-else" class="tab" data-tab="228b5a64-aaf7-4f5c-9832-3d94310f56a4" data-name="something-else"> <li class="active" id="something-else-text"> <a href="#">text </a> </li> <li id="something-else-quote"> <a href="#">quote </a> </li> <li id="something-else-list"> <a href="#">list </a> </li> </ul> <ul class="tab-content" id="228b5a64-aaf7-4f5c-9832-3d94310f56a4" data-name="something-else"> <li class="active"> <p>Regular text</p> </li> <li> <blockquote> <p>A quote</p> </blockquote> </li> <li> <p>Hipster list</p> <ul> <li>brunch</li> <li>fixie</li> <li>raybans</li> <li>messenger bag</li> </ul> </li> </ul>]]></content><author><name></name></author><category term="sample-posts"/><category term="formatting"/><category term="code"/><summary type="html"><![CDATA[this is what included tabs in a post could look like]]></summary></entry><entry><title type="html">a post with typograms</title><link href="https://xw23c.github.io/blog/2024/typograms/" rel="alternate" type="text/html" title="a post with typograms"/><published>2024-04-29T23:36:10+00:00</published><updated>2024-04-29T23:36:10+00:00</updated><id>https://xw23c.github.io/blog/2024/typograms</id><content type="html" xml:base="https://xw23c.github.io/blog/2024/typograms/"><![CDATA[<p>This is an example post with some <a href="https://github.com/google/typograms/">typograms</a> code.</p> <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="p">```</span><span class="nl">typograms
</span><span class="sb">+----+
|    |---&gt; My first diagram!
+----+</span>
<span class="p">```</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>Which generates:</p> <pre><code class="language-typograms">+----+
|    |---&gt; My first diagram!
+----+
</code></pre> <p>Another example:</p> <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre><span class="p">```</span><span class="nl">typograms
</span><span class="sb">.------------------------.
|.----------------------.|
||"https://example.com" ||
|'----------------------'|
| ______________________ |
||                      ||
||   Welcome!           ||
||                      ||
||                      ||
||  .----------------.  ||
||  | username       |  ||
||  '----------------'  ||
||  .----------------.  ||
||  |"*******"       |  ||
||  '----------------'  ||
||                      ||
||  .----------------.  ||
||  |   "Sign-up"    |  ||
||  '----------------'  ||
||                      ||
|+----------------------+|
.------------------------.</span>
<span class="p">```</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>which generates:</p> <pre><code class="language-typograms">.------------------------.
|.----------------------.|
||"https://example.com" ||
|'----------------------'|
| ______________________ |
||                      ||
||   Welcome!           ||
||                      ||
||                      ||
||  .----------------.  ||
||  | username       |  ||
||  '----------------'  ||
||  .----------------.  ||
||  |"*******"       |  ||
||  '----------------'  ||
||                      ||
||  .----------------.  ||
||  |   "Sign-up"    |  ||
||  '----------------'  ||
||                      ||
|+----------------------+|
.------------------------.
</code></pre> <p>For more examples, check out the <a href="https://google.github.io/typograms/#examples">typograms documentation</a>.</p>]]></content><author><name></name></author><category term="sample-posts"/><category term="formatting"/><category term="diagrams"/><summary type="html"><![CDATA[this is what included typograms code could look like]]></summary></entry><entry><title type="html">a post that can be cited</title><link href="https://xw23c.github.io/blog/2024/post-citation/" rel="alternate" type="text/html" title="a post that can be cited"/><published>2024-04-28T15:06:00+00:00</published><updated>2024-04-28T15:06:00+00:00</updated><id>https://xw23c.github.io/blog/2024/post-citation</id><content type="html" xml:base="https://xw23c.github.io/blog/2024/post-citation/"><![CDATA[<p>This is an example post that can be cited. The content of the post ends here, while the citation information is automatically provided below. The only thing needed is for you to set the <code class="language-plaintext highlighter-rouge">citation</code> key in the front matter to <code class="language-plaintext highlighter-rouge">true</code>.</p>]]></content><author><name></name></author><category term="sample-posts"/><category term="formatting"/><category term="citation"/><summary type="html"><![CDATA[this is what a post that can be cited looks like]]></summary></entry><entry><title type="html">a post with pseudo code</title><link href="https://xw23c.github.io/blog/2024/pseudocode/" rel="alternate" type="text/html" title="a post with pseudo code"/><published>2024-04-15T00:01:00+00:00</published><updated>2024-04-15T00:01:00+00:00</updated><id>https://xw23c.github.io/blog/2024/pseudocode</id><content type="html" xml:base="https://xw23c.github.io/blog/2024/pseudocode/"><![CDATA[<p>This is an example post with some pseudo code rendered by <a href="https://github.com/SaswatPadhi/pseudocode.js">pseudocode</a>. The example presented here is the same as the one in the <a href="https://saswat.padhi.me/pseudocode.js/">pseudocode.js</a> documentation, with only one simple but important change: everytime you would use <code class="language-plaintext highlighter-rouge">$</code>, you should use <code class="language-plaintext highlighter-rouge">$$</code> instead. Also, note that the <code class="language-plaintext highlighter-rouge">pseudocode</code> key in the front matter is set to <code class="language-plaintext highlighter-rouge">true</code> to enable the rendering of pseudo code. As an example, using this code:</p> <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="rouge-code"><pre><span class="p">```</span><span class="nl">pseudocode
</span><span class="sb">% This quicksort algorithm is extracted from Chapter 7, Introduction to Algorithms (3rd edition)
\begin{algorithm}
\caption{Quicksort}
\begin{algorithmic}
\PROCEDURE{Quicksort}{$$A, p, r$$}
    \IF{$$p &lt; r$$}
        \STATE $$q = $$ \CALL{Partition}{$$A, p, r$$}
        \STATE \CALL{Quicksort}{$$A, p, q - 1$$}
        \STATE \CALL{Quicksort}{$$A, q + 1, r$$}
    \ENDIF
\ENDPROCEDURE
\PROCEDURE{Partition}{$$A, p, r$$}
    \STATE $$x = A[r]$$
    \STATE $$i = p - 1$$
    \FOR{$$j = p$$ \TO $$r - 1$$}
        \IF{$$A[j] &lt; x$$}
            \STATE $$i = i + 1$$
            \STATE exchange
            $$A[i]$$ with $$A[j]$$
        \ENDIF
        \STATE exchange $$A[i]$$ with $$A[r]$$
    \ENDFOR
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}</span>
<span class="p">```</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>Generates:</p> <pre><code class="language-pseudocode">% This quicksort algorithm is extracted from Chapter 7, Introduction to Algorithms (3rd edition)
\begin{algorithm}
\caption{Quicksort}
\begin{algorithmic}
\PROCEDURE{Quicksort}{$$A, p, r$$}
    \IF{$$p &lt; r$$}
        \STATE $$q = $$ \CALL{Partition}{$$A, p, r$$}
        \STATE \CALL{Quicksort}{$$A, p, q - 1$$}
        \STATE \CALL{Quicksort}{$$A, q + 1, r$$}
    \ENDIF
\ENDPROCEDURE
\PROCEDURE{Partition}{$$A, p, r$$}
    \STATE $$x = A[r]$$
    \STATE $$i = p - 1$$
    \FOR{$$j = p$$ \TO $$r - 1$$}
        \IF{$$A[j] &lt; x$$}
            \STATE $$i = i + 1$$
            \STATE exchange
            $$A[i]$$ with $$A[j]$$
        \ENDIF
        \STATE exchange $$A[i]$$ with $$A[r]$$
    \ENDFOR
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}
</code></pre>]]></content><author><name></name></author><category term="sample-posts"/><category term="formatting"/><category term="code"/><summary type="html"><![CDATA[this is what included pseudo code could look like]]></summary></entry></feed>